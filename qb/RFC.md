# Query builder pre-RFC

## Generation

Generation logic should live inside inside edgedb-js so the generation logic is versioned alongside the driver.

### Generation output

Option 1: Generate into `node_modules/.edgedb` and re-export from inside the `edgedb` module. This is what Prisma does. This means the query builder typically won't be checked into version control.

Option 2: Generate to a file/directory in the local project, e.g. `./generated/edgedb.ts`. This can be customizable.

### Delegation

The `edgedb` CLI command should scan for a package.json containing `edgedb`.

1. If found, it should delegate the generation step to the installed package. It will pass the connection options to the package as arguments.
2. If a package.json is discovered but edgedb isn't installed, it can be auto-installed.
3. If the command wasn't executed inside a JS package (no `package.json` in any ancestor), error.

### Executable

The `edgedb` module can contain an executable `generate` command exposed via package.json ["bin"](https://docs.npmjs.com/cli/v7/configuring-npm/package-json#bin). Users could optionally call the package's CLI directly with `npx edgedb generate`. This doesn't causes clashes with globally installed CLIs, as `npx` doesn't look at the global path.

### Output location

Generate definitions into `node_modules/.edgedb` and re-export from `node_modules/edgedb/index.js`. This is what Prisma does.

- Keeps the generated code out of version control.
- Pro: This lets us define a bunch of TS code in the `edgedb` JS package, then reference it in the `generated` code, and the schema-specific artifacts can be generated to a particular spot in the package.

## Type system

EdgeDB's type system can be represented as either interfaces or branded types, which both support an analog of multiple interitance.

"Multiple inheritance" is used to represent implicit casting/compatibilty. e.g. `interface Int64 implements Float64, BigInt {}`.

- interface AnyType<TSType>
  - Bool
  - Bytes
  - UUID
  - String
  - Datetime
  - Duration
  - Local{Date|Time|DateTime}
  - Decimal
  - BigInt
  - Float64
  - Float32
  - Int64
  - Int32
  - Int16
  - Enum
    - auto-generated subclasses
  - Array<ElementType>
  - Tuple<Elements>
  - Link<Target extends ObjectType, Source extends ObjectType>
  - ObjectType<Properties, Links>
    - auto-generated subclasses
  - Set<ElementType extends Type, Cardinality extends "set" | "singleton" | "empty" | "atmostone" | "atleastone" = "set">

## Class structure

All syntactic structures are subclasses of `Expression` augmented with a mixin corresponding to its return type.

```ts
Expression<Output extends Set<any, any>, TSType> {}
```

Proposed subclass tree

- Expression<Output extends Set<unknown>, TSType>
  - Literal
    - subclasses
  - ObjectSetReference<ObjectType, Shape>
    - autogenerated for each object type
    - available as `e.default.Hero`, `e.default.Movie`, etc.
    - paths represented as linked links with `_parent` property
  - PropertySetReference
    - paths represented as linked links with `_parent` property
  - Statement
    - Select
    - Insert
    - Update
    - Delete
    - With
    - ForIn
  - Operator<...Args>
    - subclasses for each operator
    - plus an overloaded factory function
  - FunctionCall<...Args>
    - subclasses for each built-in function
    - plus an overloaded factory function

## Conflicts

All types, functions, and operators are generated into a single file and properly namespaced:

```ts
e.std.array_unpack;
e.default.User;
e.math.floor;
e.sys.get_version;
e.cal.datetime;
```

All operators and the `std` module are also aliased to top-level functions for convenience:

```ts
e.len;
e.eq;
```

If there are any name conflicts (e.g. a user-defined module called `len`) then the generation script will forgo aliasing `e.std.len` to `e.len`.

## Literals

These will be rendered as EdgeQL string literals.

```ts
e.str("234"); // naked string literals supported where possible
e.int64(123);
e.float64(1234.1234);
e.bool(true); // boolean literals supported where possible
e.bigint(12345n); // bigint literals supported where possible

e.decimal("1234.1234n");
e.datetime(new Date());
// same type signatures as edgedb-js constructors
e.localDate(1776, 07, 04);
e.localTime(13, 15, 0);
e.localDateTime(1776, 07, 04, 13, 15, 0);
e.duration(400, 5, 12, 1, 2, 3);
e.uuid("599236a4-2a5e-4249-91b6-ec435d3afe20");
e.json(JSON.stringify({asdf: 1234}));

e.default.CustomEnum.green;
```

## Sets and overloading

```ts
e.set(e.str("asdf"), e.str("qwer"));
// => SetLiteral<Set<String>, string[]>
```

Overload with support for naked strings

```ts
e.set("asdf", "asdf");
// => SetLiteral<Set<String>, string[]>
```

Disallow incompatible types.

```ts
e.set(e.str("asdf"), e.int32(12)); // TypeError
```

Use overloading to represent implicit casting behavior

```ts
// allow castable heterogeneous types

e.set(e.int16(1234), e.int64(1234));
// => Literal<Set<Int64>, number[]>

e.set(e.int64(1234), e.float32(12.34));
// => Literal<Set<Float64>, number[]>
```

## Arrays

```ts
e.array([e.str(5)]);
```

As with sets, heterogeneous compatible types are valid

```ts
e.array([e.int16(5), e.int64(51234)]);
```

## Tuples

Named

```ts
e.tuple({
  name: e.str("Peter Parker"),
  age: e.int64(18),
});
```

Unnamed

```ts
e.tuple([e.str("Peter Parker"), e.int64(100)]);
```

## Set references

### Object set references

Module-scoped set references. Instance of `ObjectSetReference`.

```ts
e.default.Hero;
e.default.Villain;
e.default.Movie;
e.myModule.MyType;
```

### Deconstruction for convenience

```ts
const {Hero, Villain, Movie, Person} = e.default;
```

### Property set references

Returns `PropertySetReference`.

```ts
Hero.name;
Movie.title;
```

### Traverse links

Returns another `ObjectSetReference`.

```ts
Hero.villains;
Movie.characters;
```

### Type filters

```ts
// Movie.characters[IS Hero]
Movie.characters.$is(Hero);
```

### Backward links

```ts
Hero.$back.nemesis.$is(Villain);

// Hero.$back(Villain.nemesis);
// `Hero.<nemesis`
// `Hero.<nemesis[IS Villain]`
// Hero.$of(Villain.nemesis);
// e.back(Hero, Villain.nemesis);
// sugar options
// e.is(Hero["<nemesis"]);
// Hero.nemesis_Villain;
```

## Select

### Scalars

```ts
e.select(e.int64(1243));
e.select(a.add(e.int64(2), e.int64(2)));
e.select(e.concat('aaaa', e.to_str(e.int64(111)));
```

### Simple select

Shape defaults to `{ id: true }`;

```ts
e.select(Hero);
// Select Hero;
```

### Object-defined shape

```ts
e.select(Hero, {
  id: 1 > 0, // optional
  name: true,
  villains: {
    id: true,
    name: true,
  },
});
```

### Basic filtering

```ts
e.select(Hero, {
  id: true,
  name: true,
})
  .filter(e.or(e.ilike(Hero.name, "%Man"), e.ilike(Hero.name, "The %")))
  .filter(e.ilike(Hero.secret_identity, "Peter%"));
```

> Filters are checked to determine whether the result set should be a singleton or not.

### Nested filtering

```ts
e.select(Hero, {
  id: true,
  name: true,
  villains: e
    .select(Villain.$is(Villain), {
      id: true,
      name: true,
    })
    .filter(e.eq(e.len(Hero.name), e.len(Villain.name))),
}).filter(e.eq(Hero.name, e.str("Iron Man")));
```

### Type intersection

```ts
// with h1 := Hero,
//   villains := h1.villains[IS Subvillain]

// const newHero = e.insert(Hero,{})
e.select(Hero, {
  id: true,
  name: true,
  villains: (() => {
    const villains = Hero.villains.$is(Subvillain);
    return e
      .select(villains, {
        id: true,
        name: true,
      })
      .filter(e.eq(e.len(Hero.name), e.len(villains.name)));
  })(),
}).filter(e.eq(Hero.name, e.str("Iron Man")));
```

Explicit WITH

```ts
e.select(Hero, {
  id: true,
  name: true,
  villains: e.with(
    {
      villains: Hero.villain.$is(Subvillain),
    },
    (ctx) =>
      e
        .select(ctx.villains, {
          id: true,
          name: true,
        })
        .filter(e.eq(e.len(Hero.name), e.len(villains.name)))
  ),
}).filter(e.eq(Hero.name, e.str("Iron Man")));
```

- path expressions are inlined
- statements are inlined if used only once
- statements referenced more than once require explicit WITH

### Computables

```ts
const Person = e.default.Person;

e.select(Person, {
  id: true,
  name: true,
  uppercase_name: e.str_upper(Person.name),
  is_hero: e.is(Person, e.default.Hero),
});
```

### Polymorphism

Option 1: variadic shape arguments.

```ts
e.select(
  Person,
  {
    id: true,
    name: true,
    IS_Hero: {
      secret_identity: true,
    },
  },
  e.is(Hero, {
    secret_identity: true,
    villains: {
      id: true,
      name: true,
    },
  }),
  e.is(Villain, {
    nemesis: {id: true},
  })
);
```

Potential ambiguity:

```
SELECT Movie.characters[IS Hero];
SELECT Movie.characters IS Hero;
```

### Type intersection

```
SELECT Movie {
  id,
  characters[IS Hero]: {
    id, secret_identity
  }
}
```

Use subqueries:

```ts
e.select(Movie, {
  id: true,
  characters: e.select(Movie.characters.$is(e.default.Hero), {
    id: true,
    secret_identity: true,
  }),
});
```

### Paths

Links

```ts
e.select(Hero.villains, {
  id: true,
});
```

Properties

```ts
const name = e.default.Hero.name;
e.select(name).filter(e.eq(name, "Iron Man")).orderBy(e.len(name));
```

### Ordering

```ts
e.select(Hero).orderBy(Hero.name);
e.select(Hero).orderBy(Hero.name, e.ASC);
e.select(Hero).orderBy(Hero.name, e.ASC, e.EMPTY_LAST);
```

### Multiple ordering

```ts
e.select(Hero, {
  name: true,
})
  .orderBy(Hero.name, e.DESC, e.EMPTY_FIRST)
  .orderBy(Hero.secret_identity, e.ASC, e.EMPTY_LAST);

`SELECT Hero
  ORDER BY .name DESC EMPTY LAST
  THEN .secret_identity ASC EMPTY LAST`;
```

### Pagination

```ts
e.select(Hero).offset(e.len(Hero.name)).limit(15);
```

No chained `offset` or `limit`

```ts
e.select(Hero).offset(e.len(Hero.name)).offset(15); // TypeError
```

## Insert

```ts
const Movie = e.default.Movie;
const Person = e.default.Person;

e.insert(Movie, {
  title: "Spider-Man 2",
  characters: e
    .select(Person)
    .filter(e.in(Person.name, e.set("Spider-Man", "Doc Ock"))),
});
```

### Conflicts

```ts
e.insert(Movie, {
  title: "Spider-Man 2",
  characters: e
    .select(Person)
    .filter(e.in(Person.name, e.set("Spider-Man", "Doc Ock"))),
}).unlessConflict(
  Movie.title, // can be any expression
  e.update(Movie, {
    characters: e
      .select(Person)
      .filter(e.in(Person.name, e.set("Spider-Man", "Doc Ock"))),
  })
);
```

## Update

```ts
// update method
e.select(Movie)
  .filter(e.eq(Movie.title, e.str("Avengers 4")))
  .orderBy(/**/)
  .offset(/**/)
  .update({
    set: {
      title: e.str("Avengers: Endgame"),
    },
    add: {
      characters: e.set(e.select(Hero), e.select(Villain)),
    },
    remove: {
      characters: e
        .select(Villain)
        .filter(e.eq(villain.name, e.str("Thanos"))),
    },
  });
```

## Delete

```ts
e.select(Hero)
  .filter(e.eq(Hero.name, "Captain America"))
  .orderBy(/**/)
  .offset(/**/)
  .limit(/**/)
  .delete();
```

## Detach

```ts
const detachedHero = e.detach(e.Hero);
```

## Parameters

```ts
const fetchPerson = e.withParams(
  {
    name: e.$Array(e.$Str),
  },
  (args) =>
    e
      .select(Person, {
        id: true,
      })
      .filter(e.in(Person.name, e.array_unpack(args.name)))
);
```

## WITH clauses

During the query rendering step, references to different clauses are tracked, and all orphan clauses are added in a WITH block. Expression identifiers (e.g. `WITH h1 := ()`) are generated internally.

```ts
const newHero = e.insert(Hero, {
  name: "Batman",
});

const newVillain = e.insert(Villain, {
  name: "Dr. Evil",
  nemesis: newHero,
});

return e.select(newVillain, {
  id: true,
  name: true,
});
```

If reference tracking isn't possible for some reason, alternative APIs include a "dependency list":

```ts
return e
  .with(newHero, newVillain) // list "dependencies"
  .select(newVillain, {
    id: true,
    name: true,
  });
```

or a fully self-contained version:

```ts
return e
  .with({
    newHero: e.insert(e.default.Hero, {
      name: "Batman",
    }),
  })
  .with((ctx) => ({
    villain: e.insert(e.default.Villain, {
      name: "Dr. Evil",
      nemesis: ctx.newHero,
    }),
  }))
  .query((ctx) =>
    e.select(ctx.villain, {
      id: true,
      name: true,
    })
  );
```

## Inline aliases

```ts
const x = e.select(e.set(e.int64(1), e.int64(2), e.int64(3)));
e.select(x).filter(e.gt(x, e.int64(2)));
```

Renders to:

```
SELECT x := {1,2,3} FILTER x > 2;
```

## FOR IN

As the `Set` class (described under "Type System") has a `cardinality` property, we're able to represent singleton cardinality inside a FOR/IN loop.

```ts
e.for(e.set("1", "2", "3"), (number) => {
  // do stuff
});

e.for(Hero, (hero) => {
  // do stuff
});
```

## Type declarations

```ts
e.decimal(15);
e.cast(e.decimal, 14);

e.tuple([e.int16, e.str]); // tuple<int16, str>
e.tuple([e.int16(0), e.str("asdf")]); // ('0', 'asdf')
e.tuple([Hero, Villain]); // ???
```

## Casting

All types are available at the top-level. Returns `Expression<Set<CastedType>>`. This syntax is liable to change based on the underlying representation of the type system (not finalized).

```ts
e.cast(e.Int16, e.int32(1255)); // <int16><int32>1255;
e.cast(e.UUID, e.str("ab1bcd81...")); // <int16>len(Hero.name);
```

## Functions

All operators are available as overloaded functions at the top level.

```ts
type AnyExpression = Expression<Set<any>, any>>;

class Len<Arg extends AnyExpression> extends Expression<Set<Int64, Arg["__cardinality"]>, number>{
  _expr: Arg;
}

function len<T extends Expression<Set<Bytes>, any>>(arg: T): Len<T>;
function len<T extends Expression<Set<Str>, any>>(arg: T): Len<T>;
function len<T extends Expression<Set<Array<any>>, any>>(arg: T): Len<T>;
function len(arg: any) {
  return new Len(arg) as any;
}

len(e.str("asdasdf"));
```

The overload enforces that `len` only accepts sets of `Bytes`, `Str`, or `Array` types. Also, the cardinality of the output reflects the cardinality of the input.

A class will be generated for each custom function in the schema.

## Operators

Operators are implements as top-level overloaded functions using the same approach used for functions.
